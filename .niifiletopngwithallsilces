import React from "react";
import * as nifti from "nifti-reader-js";

const App = () => {
  const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

  const handleFileUpload = async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = async () => {
      const arrayBuffer = reader.result;

      if (!nifti.isCompressed(arrayBuffer) && nifti.isNIFTI(arrayBuffer)) {
        const header = nifti.readHeader(arrayBuffer);
        const imageData = nifti.readImage(header, arrayBuffer);

        const datatypeCode = header.datatypeCode;
        let volume;
        switch (datatypeCode) {
          case nifti.NIFTI1.TYPE_UINT16:
            volume = new Uint16Array(imageData);
            break;
          case nifti.NIFTI1.TYPE_UINT8:
            volume = new Uint8Array(imageData);
            break;
          case nifti.NIFTI1.TYPE_INT16:
            volume = new Int16Array(imageData);
            break;
          case nifti.NIFTI1.TYPE_INT32:
            volume = new Int32Array(imageData);
            break;
          case nifti.NIFTI1.TYPE_FLOAT32:
            volume = new Float32Array(imageData);
            break;
          default:
            alert(" Unsupported datatype: " + datatypeCode);
            return;
        }

        const width = header.dims[1];
        const height = header.dims[2];
        const depth = header.dims[3];

        for (let z = 0; z < depth; z++) {
          const canvas = document.createElement("canvas");
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext("2d");
          const imgData = ctx.createImageData(width, height);
          const sliceOffset = z * width * height;

          let min = Infinity;
          let max = -Infinity;
          for (let i = 0; i < width * height; i++) {
            const val = volume[sliceOffset + i];
            if (val < min) min = val;
            if (val > max) max = val;
          }

          for (let i = 0; i < width * height; i++) {
            const norm = (volume[sliceOffset + i] - min) / (max - min || 1);
            const pixelVal = Math.floor(norm * 255);
            imgData.data[i * 4 + 0] = pixelVal;
            imgData.data[i * 4 + 1] = pixelVal;
            imgData.data[i * 4 + 2] = pixelVal;
            imgData.data[i * 4 + 3] = 255;
          }

          ctx.putImageData(imgData, 0, 0);

          const blob = await new Promise((resolve) =>
            canvas.toBlob(resolve, "image/png")
          );
          const url = URL.createObjectURL(blob);

          const a = document.createElement("a");
          a.href = url;
          a.download = `slice_${String(z).padStart(3, "0")}.png`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          await sleep(100); // 1 ms wait for each slie to be downloaded 
          
        }
      } else {
        alert(" Not a valid uncompressed NIfTI file");
      }
    };
    reader.readAsArrayBuffer(file);
  };

  return (
    <div style={{ textAlign: "center" }}>
      <h2>Convert .nii to PNG slices (Direct Download with Delay)</h2>
      <input type="file" accept=".nii" onChange={handleFileUpload} />
    </div>
  );
};

export default App;
